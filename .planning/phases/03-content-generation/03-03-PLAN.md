---
phase: 03-content-generation
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - app/services/script_generator.py
  - app/tasks.py
  - app/api/routes.py
autonomous: true

must_haves:
  truths:
    - "Claude API generates Video Production Plans via 5-step prompt chain (theme interpretation, trend alignment, scene construction, narration, text overlay design) — all 5 conceptual steps preserved, optimized into 2 API calls"
    - "Generated scripts align with current trend patterns from analysis stage"
    - "Content generation task chains: read config -> generate script -> generate video clips -> generate voiceover -> returns separate video_path + audio_path (compositing deferred to Phase 4)"
    - "Mock mode produces realistic production plans without Claude API key"
    - "API endpoint triggers content generation and returns task ID"
  artifacts:
    - path: "app/services/script_generator.py"
      provides: "Claude 5-step prompt chain with tool-use structured outputs and mock fallback"
      exports: ["generate_production_plan"]
    - path: "app/tasks.py"
      provides: "generate_content_task Celery task orchestrating full pipeline"
      contains: "generate_content_task"
    - path: "app/api/routes.py"
      provides: "POST /generate-content endpoint and GET /scripts endpoints"
      contains: "generate-content"
  key_links:
    - from: "app/services/script_generator.py"
      to: "app/services/trend_reporter.py"
      via: "Fetches latest TrendReport for trend alignment"
      pattern: "get_latest_report"
    - from: "app/services/script_generator.py"
      to: "app/schemas.py"
      via: "Uses VideoProductionPlanCreate as Claude tool-use schema"
      pattern: "VideoProductionPlanCreate"
    - from: "app/tasks.py"
      to: "app/services/script_generator.py"
      via: "generate_content_task calls generate_production_plan"
      pattern: "generate_production_plan"
    - from: "app/tasks.py"
      to: "app/services/video_generator/generator.py"
      via: "generate_content_task calls video generator with scenes"
      pattern: "get_video_generator"
    - from: "app/tasks.py"
      to: "app/services/voiceover_generator/generator.py"
      via: "generate_content_task calls voiceover generator with script"
      pattern: "get_voiceover_generator"
---

<objective>
Build the Claude-powered script generation pipeline and integrate all content generation services into a Celery task chain with API endpoints.

Purpose: This is the integration plan that connects config reading (Plan 01), video generation (Plan 02), and voiceover generation (Plan 02) into a working end-to-end content pipeline. The script generator is the brain -- it reads theme config + trend data and produces the Video Production Plan that drives video and voiceover generation.

Output: Working script generator with 5-step Claude prompt chain (with mock fallback), Celery task that orchestrates config -> script -> video -> voiceover pipeline, and API endpoints for triggering and querying content generation.
</objective>

<execution_context>
@/Users/naokitsk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naokitsk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-content-generation/03-RESEARCH.md
@.planning/phases/03-content-generation/03-01-SUMMARY.md
@.planning/phases/03-content-generation/03-02-SUMMARY.md
@.planning/phases/02-trend-intelligence/02-03-SUMMARY.md
@app/services/trend_analyzer.py
@app/services/trend_reporter.py
@app/schemas.py
@app/models.py
@app/tasks.py
@app/api/routes.py
@app/config.py
@app/worker.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Claude 5-step prompt chain script generator with mock mode</name>
  <files>app/services/script_generator.py</files>
  <action>
Create `app/services/script_generator.py` implementing the 5-step Claude prompt chain for Video Production Plan generation.

**Structure:**

1. **Prompt templates** - Define 5 prompt strings (can be module-level constants or a dict):
   - **Step 1 - Theme Interpretation:** Takes ThemeConfig + ContentReference data. Asks Claude to analyze core message, target audience, emotional tone, key selling points.
   - **Step 2 - Trend Alignment:** Takes Step 1 output + latest TrendReport data (video_styles, common_patterns, top_hashtags). Asks Claude to select best trend patterns for this theme, choose style classification, identify engagement hooks.
   - **Step 3 - Scene Construction:** Takes Steps 1+2 output. Asks Claude to build scene breakdown (3-7 scenes, 2-4 seconds each) with visual prompts for AI video generation. Must sum to duration_target. Include transitions.
   - **Step 4 - Narration Script:** Takes Steps 1+2+3 output. Asks Claude to write voiceover_script matching scene timing, hook_text for first 3 seconds, cta_text for final seconds.
   - **Step 5 - Text Overlay Design:** Takes all previous outputs. Asks Claude to design text_overlays with timing/position, generate hashtags, title, and description.

2. **`generate_production_plan(theme_config: dict, content_refs: List[dict], trend_report: Optional[dict] = None) -> dict`**:
   - If `settings.use_mock_data` or `settings.anthropic_api_key` is empty: call `_generate_mock_plan(theme_config, content_refs)`
   - Otherwise: execute the 5-step chain using Claude tool-use pattern
   - For each step, use the tool-use pattern established in Phase 2 (trend_analyzer.py):
     ```python
     # Reuse _add_additional_properties_false from trend_analyzer
     from app.services.trend_analyzer import _add_additional_properties_false

     # Use Claude tool-use for the FINAL step only (steps 1-4 can use free-form text)
     # This is more efficient: only the final output needs strict schema compliance
     # Steps 1-4 use regular messages, step 5 aggregates everything into structured output
     ```
   - **Optimization:** All 5 conceptual steps from the SCRIPT-02 prompt chain are preserved, but batched into 2 API calls instead of 5 separate calls:
     - Call 1 (Steps 1-4): Theme Interpretation + Trend Alignment + Scene Construction + Narration Script — combined into a single detailed prompt. Claude performs all four reasoning steps in one pass, returning free-form analysis text covering each step.
     - Call 2 (Step 5): Text Overlay Design + structured output assembly — takes the analysis from Call 1 + original inputs. Uses tool-use pattern with VideoProductionPlanCreate schema to produce the final structured VideoProductionPlan.
   - This is an efficiency optimization only. The intellectual work of all 5 steps (theme interpretation, trend alignment, scene construction, narration, text overlay design) is fully performed — just batched into 2 API calls to reduce latency and cost.
   - Wrap Claude calls in try/except. On ANY error, log warning and fall back to `_generate_mock_plan()`.
   - Use `anthropic.Anthropic(api_key=settings.anthropic_api_key)` client.
   - Use `claude-sonnet-4-20250514` model (cost-efficient, same as trend_analyzer).

3. **`_generate_mock_plan(theme_config: dict, content_refs: List[dict]) -> dict`**:
   - Return a realistic VideoProductionPlan dict with:
     - `video_prompt`: Based on theme_config theme/style
     - `duration_target`: From theme_config.video_duration_seconds (or default 20)
     - `aspect_ratio`: "9:16"
     - `scenes`: 5 scenes of 4 seconds each (or divided evenly from duration_target)
     - `voiceover_script`: 2-3 sentences incorporating product talking points
     - `hook_text`: Attention-grabbing first line
     - `cta_text`: "Follow for more" style CTA
     - `text_overlays`: 3-4 overlays at different timestamps
     - `hashtags`: 5-8 relevant hashtags (mix of generic viral + product-specific)
     - `title`: Short catchy title
     - `description`: Platform-optimized description
   - Validate against VideoProductionPlanCreate schema before returning

4. **`_save_production_plan(plan_data: dict, theme_config: dict, trend_report_id: Optional[int] = None) -> int`**:
   - Save to Script table in database using async session (same pattern as trend_reporter.py)
   - Store theme_config as JSON snapshot
   - Return script ID

Use `from typing import List, Dict, Any, Optional` (Python 3.9). Follow the established Claude API pattern from `app/services/trend_analyzer.py`.
  </action>
  <verify>
```python
from app.services.script_generator import generate_production_plan, _generate_mock_plan
from app.services.config_reader import read_theme_config, read_content_references

# Test mock plan generation
config = read_theme_config()
refs = read_content_references()
plan = generate_production_plan(
    theme_config=config.model_dump(),
    content_refs=[r.model_dump() for r in refs]
)
assert 'video_prompt' in plan
assert 'scenes' in plan
assert 'voiceover_script' in plan
assert 'hashtags' in plan
assert 'title' in plan
assert 'description' in plan
assert 'text_overlays' in plan
assert 'hook_text' in plan
assert 'cta_text' in plan
assert plan['aspect_ratio'] == '9:16'
assert len(plan['scenes']) >= 3
print(f"Production plan: {plan['title']}")
print(f"Scenes: {len(plan['scenes'])}, Duration: {plan['duration_target']}s")
print(f"Hashtags: {plan['hashtags'][:3]}")
```
  </verify>
  <done>generate_production_plan() returns complete VideoProductionPlan with all 11 fields. Mock mode produces realistic plans from theme config. Claude API integration uses tool-use pattern with automatic fallback to mock on errors. Plan data validates against VideoProductionPlanCreate schema.</done>
</task>

<task type="auto">
  <name>Task 2: Content generation Celery task and API endpoints</name>
  <files>app/tasks.py, app/api/routes.py</files>
  <action>
**Add to `app/tasks.py`:**

1. **`generate_content_task`** Celery task:
   - Decorated with same pattern as existing tasks:
     ```python
     @celery_app.task(
         bind=True,
         name='app.tasks.generate_content_task',
         max_retries=2,
         autoretry_for=(Exception,),
         retry_backoff=True,
         retry_backoff_max=600,
         retry_jitter=True,
     )
     def generate_content_task(self, theme_config_path: Optional[str] = None):
     ```
   - Pipeline steps (each step uses imports inside function body to avoid circular imports):
     a. **Read config:** Call `read_theme_config()` and `read_content_references()` from config_reader
     b. **Get trend data:** Call `asyncio.run(get_latest_report())` from trend_reporter (or None if no reports exist)
     c. **Generate script:** Call `generate_production_plan(config, refs, trend_data)`
     d. **Save script to DB:** Call `asyncio.run(_save_production_plan(plan, config, trend_report_id))`
     e. **Generate video clips:** Call `get_video_generator().generate_video(plan['scenes'], plan['duration_target'])`
     f. **Generate voiceover:** Call `get_voiceover_generator().generate_voiceover(plan['voiceover_script'])`
     g. **Return result dict** with script_id, video_path, audio_path, status
   - Log each step with `logger.info()`
   - On error at any step, log and re-raise (Celery retry handles it)

2. **`get_latest_report()` helper** (add to trend_reporter.py or inline):
   - Query latest TrendReport from DB
   - Return as dict (or None if no reports)
   - This is the bridge between Phase 2 output and Phase 3 input

**Add to `app/api/routes.py`:**

3. **POST /generate-content** endpoint:
   - Triggers `generate_content_task.delay()`
   - Returns `{"task_id": task.id, "status": "queued"}`

4. **GET /scripts** endpoint:
   - Lists generated scripts (from Script table)
   - Returns id, title, duration_target, aspect_ratio, created_at
   - Default limit 10, ordered by created_at DESC

5. **GET /scripts/{script_id}** endpoint:
   - Returns full script details including scenes, text_overlays, voiceover_script, hashtags
   - 404 if not found

Follow established patterns from existing routes.py (same import style, response format, error handling). Use `from typing import Optional` (Python 3.9).
  </action>
  <verify>
```bash
cd /Users/naokitsk/Documents/short-video-generator

# Verify task registration
python -c "
from app.tasks import generate_content_task
print(f'Task name: {generate_content_task.name}')
print('Task registered successfully')
"

# Test endpoint availability (start server briefly)
python -c "
from app.api.routes import router
routes = [r.path for r in router.routes]
assert '/generate-content' in routes or any('generate-content' in str(r.path) for r in router.routes)
assert '/scripts' in routes or any('scripts' in str(r.path) for r in router.routes)
print('Endpoints registered:', [r.path for r in router.routes])
"

# End-to-end test with mock data
python -c "
import asyncio
from app.services.config_reader import read_theme_config, read_content_references
from app.services.script_generator import generate_production_plan
from app.services.video_generator.generator import get_video_generator
from app.services.voiceover_generator.generator import get_voiceover_generator

# Step 1: Config
config = read_theme_config()
refs = read_content_references()
print(f'Config: {config.theme}')

# Step 2: Generate script
plan = generate_production_plan(config.model_dump(), [r.model_dump() for r in refs])
print(f'Script: {plan[\"title\"]}')

# Step 3: Generate video
video_gen = get_video_generator()
video_path = video_gen.generate_video(plan['scenes'], plan['duration_target'])
print(f'Video: {video_path}')

# Step 4: Generate voiceover
voice_gen = get_voiceover_generator()
audio_path = voice_gen.generate_voiceover(plan['voiceover_script'])
print(f'Audio: {audio_path}')

print('End-to-end content generation PASSED')
"
```
  </verify>
  <done>generate_content_task chains config -> script -> video -> voiceover in single Celery task. POST /generate-content triggers the pipeline. GET /scripts and GET /scripts/{id} query generated scripts. End-to-end mock pipeline produces script, video MP4, and audio file from sample-data.yml config. Note: video_path and audio_path are returned as separate raw assets — compositing (FFmpeg merging video + voiceover audio + text overlays into final MP4) is deferred to Phase 4 (Video Composition). The generate_content_task result dict contains {script_id, video_path, audio_path, status} as Phase 4's inputs.</done>
</task>

</tasks>

<verification>
1. `python -c "from app.services.script_generator import generate_production_plan; print('Script gen OK')"` imports clean
2. `python -c "from app.tasks import generate_content_task; print(generate_content_task.name)"` shows task name
3. End-to-end mock test: config -> script -> video -> voiceover completes without errors
4. Generated script has all 11 required fields (video_prompt, duration_target, aspect_ratio, scenes, voiceover_script, hook_text, cta_text, text_overlays, hashtags, title, description)
5. Generated video is MP4 file at 9:16 aspect ratio
6. Generated audio is MP3/WAV file with duration > 0
7. POST /generate-content endpoint returns task_id
8. GET /scripts returns list of generated scripts
</verification>

<success_criteria>
- Claude 5-step prompt chain produces VideoProductionPlan (all 5 conceptual steps — theme interpretation, trend alignment, scene construction, narration, text overlay design — executed in 2 optimized API calls)
- Mock mode returns realistic plan without API key
- Claude errors fall back to mock gracefully
- Celery task chains all 4 generation steps (config -> script -> video -> voiceover)
- Script saved to database with all fields
- POST /generate-content triggers pipeline
- GET /scripts and GET /scripts/{id} query results
- Full end-to-end flow works with USE_MOCK_DATA=true
- Trend report data from Phase 2 feeds into script generation when available
- generate_content_task returns {script_id, video_path, audio_path, status} — video and audio are separate raw assets, NOT composited. Compositing into final MP4 (video + voiceover + text overlays) is Phase 4's responsibility.
</success_criteria>

<output>
After completion, create `.planning/phases/03-content-generation/03-03-SUMMARY.md`
</output>
