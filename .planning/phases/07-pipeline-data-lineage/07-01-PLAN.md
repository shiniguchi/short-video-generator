---
phase: 07-pipeline-data-lineage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/pipeline.py
  - app/tasks.py
  - app/services/script_generator.py
  - .planning/REQUIREMENTS.md
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "orchestrate_pipeline_task passes job_id to generate_content_task"
    - "save_production_plan accepts job_id and populates Script.job_id in database"
    - "compose_video_task accepts job_id and populates Video.job_id in database"
    - "After full pipeline run, Job record can query its associated Script and Video via foreign keys"
    - "REQUIREMENTS.md ORCH-01 reflects 5 orchestration stages, not 8"
  artifacts:
    - path: "app/pipeline.py"
      provides: "job_id threading to generate_content_task"
      contains: "generate_content_task, [job_id"
    - path: "app/tasks.py"
      provides: "job_id parameter in generate_content_task and compose_video_task"
      contains: "def generate_content_task(self, job_id: int"
    - path: "app/services/script_generator.py"
      provides: "job_id population in Script record"
      contains: "job_id=job_id"
    - path: ".planning/REQUIREMENTS.md"
      provides: "Updated ORCH-01 text"
      contains: "5 orchestration stages"
  key_links:
    - from: "app/pipeline.py"
      to: "app/tasks.py:generate_content_task"
      via: "job_id passed as first positional arg in stage_tasks list"
      pattern: "STAGE_CONTENT_GENERATION, generate_content_task, \\[job_id"
    - from: "app/tasks.py:generate_content_task"
      to: "app/services/script_generator.py:save_production_plan"
      via: "job_id kwarg in asyncio.run call"
      pattern: "save_production_plan\\(.*job_id=job_id"
    - from: "app/tasks.py:generate_content_task"
      to: "app/tasks.py:compose_video_task"
      via: "job_id passed as first arg in compose_video_task.delay call"
      pattern: "compose_video_task\\.delay\\(job_id"
    - from: "app/tasks.py:compose_video_task"
      to: "app/models.Video"
      via: "job_id populated in _save_video_record"
      pattern: "job_id=job_id"
---

<objective>
Thread job_id through the entire pipeline task chain so that Script and Video database records link back to their originating Job, restoring full data lineage.

Purpose: Without job_id propagation, Job records have no way to query their Script and Video outputs. Foreign key columns exist in the database (Script.job_id, Video.job_id) but are never populated. This breaks data lineage and checkpoint auditability.

Output: After this plan, a full pipeline run produces Script and Video records with non-NULL job_id foreign keys pointing to the orchestrating Job.
</objective>

<execution_context>
@/Users/naokitsk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naokitsk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-pipeline-data-lineage/07-RESEARCH.md
@app/pipeline.py
@app/tasks.py
@app/services/script_generator.py
@app/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Thread job_id through pipeline orchestrator, content task, and composition task</name>
  <files>
    app/pipeline.py
    app/tasks.py
    app/services/script_generator.py
  </files>
  <action>
    Make four changes to thread job_id from orchestrator through all downstream tasks:

    **Change 1 — app/pipeline.py (orchestrate_pipeline_task):**
    In the `stage_tasks` list (around line 217), update the `STAGE_CONTENT_GENERATION` entry to pass `job_id` as the first argument:
    ```python
    (STAGE_CONTENT_GENERATION, generate_content_task, [job_id, theme_config_path]),
    ```
    Previously it was `[theme_config_path]`. Now `job_id` is the first positional arg.

    **Change 2 — app/tasks.py (generate_content_task):**
    Update function signature on line 100 to accept `job_id` as first parameter:
    ```python
    def generate_content_task(self, job_id: int, theme_config_path: Optional[str] = None):
    ```
    Update the log message to include job_id:
    ```python
    logger.info(f"Starting content generation for job {job_id} (attempt {self.request.retries + 1})")
    ```
    Update the `save_production_plan` call (around line 140) to pass `job_id`:
    ```python
    script_id = asyncio.run(save_production_plan(
        plan_data=plan,
        theme_config=config.model_dump(),
        trend_report_id=trend_report_id,
        job_id=job_id
    ))
    ```
    Update the `compose_video_task.delay` call (around line 173) to pass `job_id` as first arg:
    ```python
    compose_result = compose_video_task.delay(job_id, script_id, video_path, audio_path, cost_data)
    ```

    **Change 3 — app/tasks.py (compose_video_task):**
    Update function signature (around line 199) to accept `job_id` as first parameter:
    ```python
    def compose_video_task(self, job_id: int, script_id: int, video_path: str, audio_path: str, cost_data: dict = None):
    ```
    Update the log message:
    ```python
    logger.info(f"Starting video composition for job {job_id}, script {script_id} (attempt {self.request.retries + 1})")
    ```
    Update the inner `_save_video_record` function signature to accept `job_id`:
    ```python
    async def _save_video_record(job_id: int, script_id: int, file_path: str, thumbnail_path: str,
                                  duration: float, cost_usd: float, generation_metadata: dict):
    ```
    Add `job_id=job_id` to the Video() constructor inside `_save_video_record`:
    ```python
    video = Video(
        job_id=job_id,
        script_id=script_id,
        file_path=file_path,
        ...
    )
    ```
    Update the `asyncio.run(_save_video_record(...))` call to pass `job_id`:
    ```python
    video_id = asyncio.run(_save_video_record(
        job_id=job_id,
        script_id=script_id,
        file_path=result["video_path"],
        thumbnail_path=result["thumbnail_path"],
        duration=result["duration"],
        cost_usd=total_cost,
        generation_metadata=generation_metadata
    ))
    ```

    **Change 4 — app/services/script_generator.py (save_production_plan):**
    Update function signature (around line 357) to accept `job_id`:
    ```python
    async def save_production_plan(
        plan_data: dict,
        theme_config: dict,
        trend_report_id: Optional[int] = None,
        job_id: Optional[int] = None
    ) -> int:
    ```
    Add `job_id` to the docstring Args section.
    Add `job_id=job_id` to the Script() constructor:
    ```python
    script = Script(
        job_id=job_id,
        video_prompt=plan_data['video_prompt'],
        ...
    )
    ```
    Update log message:
    ```python
    logger.info(f"Saved production plan as Script ID {script.id} for Job {job_id}: '{script.title}'")
    ```

    **IMPORTANT:** Do NOT add relationship() objects to models.py. Foreign key columns already exist. Do NOT modify models.py at all.
    **IMPORTANT:** Use `from typing import Optional` (Python 3.9 compatibility).
  </action>
  <verify>
    Run `python -c "from app.tasks import generate_content_task, compose_video_task; from app.services.script_generator import save_production_plan; from app.pipeline import orchestrate_pipeline_task; print('All imports OK')"` from venv to verify no import errors.

    Grep to confirm all 4 key links are wired:
    1. `rg "job_id, theme_config_path" app/pipeline.py` — orchestrator passes job_id
    2. `rg "def generate_content_task.*job_id" app/tasks.py` — content task accepts job_id
    3. `rg "job_id=job_id" app/services/script_generator.py` — save_production_plan populates Script.job_id
    4. `rg "def compose_video_task.*job_id" app/tasks.py` — compose task accepts job_id
    5. `rg "compose_video_task.delay\(job_id" app/tasks.py` — content task passes job_id to compose
    6. `rg "job_id=job_id" app/tasks.py` — compose task populates Video.job_id
  </verify>
  <done>
    All 4 files updated. job_id flows: orchestrator -> generate_content_task -> save_production_plan (Script.job_id populated) and -> compose_video_task -> _save_video_record (Video.job_id populated). Import check passes. All 6 grep checks find matches.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update REQUIREMENTS.md ORCH-01 to reflect 5 orchestration stages</name>
  <files>
    .planning/REQUIREMENTS.md
  </files>
  <action>
    Update the ORCH-01 requirement text in .planning/REQUIREMENTS.md.

    **Current text (line 75):**
    ```
    - [ ] **ORCH-01**: Full 8-stage pipeline executes sequentially: trend → analysis → script → video → voiceover → composition → review
    ```

    **Updated text:**
    ```
    - [ ] **ORCH-01**: Full 5-stage pipeline executes sequentially: trend_collection → trend_analysis → content_generation (script + video + voiceover) → composition → review
    ```

    This reflects the consolidated design where script generation, video generation, and voiceover synthesis are combined into a single `content_generation` Celery task (generate_content_task), and composition is chained automatically from content generation. The pipeline has 5 orchestration stages, not 8 separate ones.
  </action>
  <verify>
    `rg "ORCH-01.*5-stage" .planning/REQUIREMENTS.md` returns the updated line.
    `rg "8-stage" .planning/REQUIREMENTS.md` returns no matches (old text removed).
  </verify>
  <done>
    ORCH-01 in REQUIREMENTS.md accurately describes 5 orchestration stages matching the actual pipeline implementation in app/pipeline.py.
  </done>
</task>

</tasks>

<verification>
1. All imports work: `python -c "from app.pipeline import orchestrate_pipeline_task; from app.tasks import generate_content_task, compose_video_task; print('OK')"`
2. job_id parameter chain is complete (6 grep checks from Task 1)
3. No `relationship()` objects added to models.py
4. ORCH-01 text updated from "8-stage" to "5-stage"
5. No new dependencies added to requirements.txt
6. Python 3.9 compatible syntax used throughout (typing imports, no `list[str]`)
</verification>

<success_criteria>
- job_id threads from orchestrate_pipeline_task through generate_content_task to both save_production_plan (Script.job_id) and compose_video_task (_save_video_record → Video.job_id)
- After a pipeline run triggered by the orchestrator, Script and Video records have non-NULL job_id foreign keys
- REQUIREMENTS.md ORCH-01 says "5-stage" not "8-stage"
- Zero new files created, zero new dependencies, zero model changes
</success_criteria>

<output>
After completion, create `.planning/phases/07-pipeline-data-lineage/07-01-SUMMARY.md`
</output>
