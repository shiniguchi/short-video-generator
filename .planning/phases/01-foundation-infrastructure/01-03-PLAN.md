---
phase: 01-foundation-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - app/main.py
  - app/api/__init__.py
  - app/api/routes.py
  - app/worker.py
  - app/tasks.py
autonomous: false

must_haves:
  truths:
    - "FastAPI health check endpoint returns service status"
    - "Celery workers connect to Redis broker"
    - "Test task executes successfully via Celery"
  artifacts:
    - path: "app/main.py"
      provides: "FastAPI application entry point"
      min_lines: 15
      contains: "FastAPI\\("
    - path: "app/api/routes.py"
      provides: "API endpoints including /health"
      min_lines: 20
      exports: ["router"]
    - path: "app/worker.py"
      provides: "Celery app configuration"
      min_lines: 30
      exports: ["celery_app"]
    - path: "app/tasks.py"
      provides: "Celery task definitions"
      contains: "@celery_app.task"
  key_links:
    - from: "app/main.py"
      to: "app/api/routes.py"
      via: "router inclusion"
      pattern: "app\\.include_router"
    - from: "app/worker.py"
      to: "app/config.py"
      via: "settings.celery_broker_url"
      pattern: "get_settings\\(\\)\\.celery_broker_url"
    - from: "app/api/routes.py"
      to: "app/tasks.py"
      via: "task.delay() dispatch"
      pattern: "\\.delay\\("
---

<objective>
Establish FastAPI REST API and Celery task queue with health monitoring and test task execution.

Purpose: Create HTTP API for pipeline control and async task execution infrastructure for long-running operations.
Output: Working API with health check endpoint and Celery worker executing test tasks successfully.
</objective>

<execution_context>
@/Users/naokitsk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naokitsk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Create FastAPI application with health endpoint</name>
  <files>
    app/main.py
    app/api/__init__.py
    app/api/routes.py
  </files>
  <action>
Create app/main.py with FastAPI app and lifespan events:

```python
from fastapi import FastAPI
from contextlib import asynccontextmanager
from app.api import routes
from app.config import get_settings

settings = get_settings()

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    print("Starting ViralForge API...")
    yield
    # Shutdown
    print("Shutting down ViralForge API...")

app = FastAPI(
    title="ViralForge API",
    description="Short-form video generation pipeline",
    version="1.0.0",
    lifespan=lifespan
)

app.include_router(routes.router)
```

Create app/api/__init__.py (empty package file).

Create app/api/routes.py with health check endpoint per research example:

```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text
from app.database import get_session
from app.config import get_settings
import redis.asyncio as redis

router = APIRouter()

@router.get("/health")
async def health_check(session: AsyncSession = Depends(get_session)):
    """Health check endpoint with service status"""
    settings = get_settings()

    # Check database
    db_status = "disconnected"
    try:
        await session.execute(text("SELECT 1"))
        db_status = "connected"
    except Exception as e:
        db_status = f"error: {str(e)}"

    # Check Redis
    redis_status = "disconnected"
    try:
        r = redis.from_url(settings.redis_url)
        await r.ping()
        redis_status = "connected"
        await r.close()
    except Exception as e:
        redis_status = f"error: {str(e)}"

    overall_status = "healthy" if db_status == "connected" and redis_status == "connected" else "unhealthy"

    return {
        "status": overall_status,
        "database": db_status,
        "redis": redis_status,
        "version": "1.0.0"
    }

@router.post("/test-task")
async def trigger_test_task():
    """Trigger a test Celery task"""
    from app.tasks import test_task
    task = test_task.delay()
    return {"task_id": str(task.id), "status": "queued"}
```

Health check follows research pattern (code example section) with database and Redis connectivity checks.
  </action>
  <verify>
Test health endpoint: `curl http://localhost:8000/health` — should return JSON with status "healthy" and database/redis "connected".
  </verify>
  <done>
FastAPI app starts on port 8000, /health endpoint returns service status, /test-task endpoint accepts POST requests.
  </done>
</task>

<task type="auto">
  <name>Create Celery worker with configuration</name>
  <files>
    app/worker.py
    app/tasks.py
  </files>
  <action>
Create app/worker.py with Celery configuration per research Pattern 3 and code example:

```python
from celery import Celery
from app.config import get_settings

settings = get_settings()

celery_app = Celery(
    "viralforge_worker",
    broker=settings.celery_broker_url,
    backend=settings.celery_result_backend
)

celery_app.conf.update(
    task_serializer='json',
    accept_content=['json'],
    result_serializer='json',
    timezone='UTC',
    enable_utc=True,
    task_track_started=True,
    task_time_limit=30 * 60,  # 30 minutes
    task_soft_time_limit=25 * 60,  # 25 minutes
    worker_prefetch_multiplier=1,  # One task at a time (important for long tasks)
    worker_max_tasks_per_child=1000,  # Restart worker after 1000 tasks (memory cleanup)
)

# Auto-discover tasks from app.tasks module
celery_app.autodiscover_tasks(['app'])
```

Create app/tasks.py with test task:

```python
from app.worker import celery_app
import time

@celery_app.task(bind=True, max_retries=3)
def test_task(self):
    """Simple test task to verify Celery is working"""
    try:
        print("Test task started")
        time.sleep(2)  # Simulate work
        print("Test task completed")
        return {"status": "success", "message": "Test task executed successfully"}
    except Exception as exc:
        print(f"Test task failed: {exc}")
        raise self.retry(exc=exc, countdown=60)
```

Use bind=True and self.retry() per research Pattern 3 for proper retry handling.

Research Pitfall 1 WARNING: Never use .get() or .wait() on task results in FastAPI endpoints — this blocks the event loop. Always use .delay() and return immediately.
  </action>
  <verify>
Check Celery worker logs: `docker compose logs celery-worker --tail=20` — should show "ready" and "viralforge_worker" connected to Redis.
  </verify>
  <done>
Celery app configured, worker connects to Redis broker, test_task registered and discoverable.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete foundation infrastructure: Docker services, FastAPI health endpoint, Celery worker, test task execution.

All services automated and running via docker-compose.
  </what-built>
  <how-to-verify>
1. Check all services are healthy:
   ```bash
   docker compose ps
   ```
   Expected: All 4 services show "Up" and "(healthy)" status

2. Test health endpoint:
   ```bash
   curl http://localhost:8000/health
   ```
   Expected: JSON response with `"status": "healthy"`, `"database": "connected"`, `"redis": "connected"`

3. Trigger test task:
   ```bash
   curl -X POST http://localhost:8000/test-task
   ```
   Expected: JSON response with `task_id` and `"status": "queued"`

4. Check Celery worker executed the task:
   ```bash
   docker compose logs celery-worker --tail=30
   ```
   Expected: Logs show "Test task started" and "Test task completed"

5. Verify no errors in any service logs:
   ```bash
   docker compose logs --tail=50
   ```
   Expected: No "connection refused", "permission denied", or exception tracebacks
  </how-to-verify>
  <resume-signal>
Type "approved" if all verifications pass, or describe any issues found.
  </resume-signal>
</task>

</tasks>

<verification>
1. All Docker services healthy: `docker compose ps`
2. Health endpoint accessible: `curl http://localhost:8000/health`
3. Test task endpoint works: `curl -X POST http://localhost:8000/test-task`
4. Celery worker processes task: Check logs for "Test task completed"
5. No errors in logs: `docker compose logs --tail=100`
</verification>

<success_criteria>
- FastAPI serves on http://localhost:8000
- /health endpoint returns "healthy" status with database and Redis connected
- /test-task endpoint triggers Celery task successfully
- Celery worker logs show task execution ("Test task started" → "Test task completed")
- All services show healthy status in `docker compose ps`
- No connection errors or exceptions in any service logs
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-03-SUMMARY.md`
</output>
