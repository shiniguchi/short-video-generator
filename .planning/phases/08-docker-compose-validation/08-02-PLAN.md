---
phase: 08-docker-compose-validation
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - scripts/validate-docker.sh
autonomous: false

must_haves:
  truths:
    - "Validation script checks compose syntax, starts services, verifies health, triggers pipeline, and checks logs"
    - "Full pipeline trigger via POST /generate completes and returns a job_id"
    - "Docker logs show output from pipeline stages (trend collection, analysis, content generation, composition, review)"
    - "User confirms Docker stack runs end-to-end"
  artifacts:
    - path: "scripts/validate-docker.sh"
      provides: "Automated Docker Compose validation script"
      contains: "docker compose"
  key_links:
    - from: "scripts/validate-docker.sh"
      to: "docker-compose.yml"
      via: "docker compose commands"
      pattern: "docker compose"
    - from: "scripts/validate-docker.sh"
      to: "/generate endpoint"
      via: "curl POST request"
      pattern: "curl.*generate"
    - from: "scripts/validate-docker.sh"
      to: "/jobs/{id} endpoint"
      via: "curl GET for job status polling"
      pattern: "curl.*jobs"
---

<objective>
Create an automated validation script that verifies the full Docker Compose stack, then run it with user confirmation.

Purpose: Provides a repeatable, automated way to validate the Docker environment works end-to-end. Closes the INFRA-01 gap from the v1.0 audit. Also serves as future CI/CD validation step.

Output: `scripts/validate-docker.sh` that validates syntax, health, pipeline execution, and logs.
</objective>

<execution_context>
@/Users/naokitsk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naokitsk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-docker-compose-validation/08-RESEARCH.md
@.planning/phases/08-docker-compose-validation/08-01-SUMMARY.md
@docker-compose.yml
@app/api/routes.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validation script</name>
  <files>scripts/validate-docker.sh</files>
  <action>
Create `scripts/validate-docker.sh` with the following 6-step validation flow:

```
#!/bin/bash
set -e
```

**Variables:**
- `HEALTH_URL="http://localhost:8000/health"`
- `GENERATE_URL="http://localhost:8000/generate"`
- `JOBS_URL="http://localhost:8000/jobs"`
- `TIMEOUT=120` (seconds, generous for first-boot migration + build)

**Step 1: Validate docker-compose.yml syntax**
- Run `docker compose config --quiet`
- Exit 1 on failure with clear error message

**Step 2: Build and start services**
- Run `docker compose up -d --build`
- This rebuilds images (ensures latest code) and starts detached

**Step 3: Wait for all services healthy**
- Loop with timeout checking `docker compose ps`
- Count services showing "(healthy)" status
- Need at least 3 healthy services (postgres, redis, web) -- celery-worker does not have a healthcheck
- On timeout: print `docker compose logs`, run `docker compose down`, exit 1
- On unhealthy: same cleanup and exit

**Step 4: Test health endpoint**
- Retry curl up to 10 times with 3s sleep between attempts
- Parse response for `"status":"healthy"`
- Also verify `"database":"connected"` and `"redis":"connected"` appear in response
- On failure: print response body, cleanup, exit 1

**Step 5: Trigger full pipeline and poll for completion**
- `curl -s -X POST "$GENERATE_URL" -H "Content-Type: application/json"`
- Extract job_id from response (use grep/cut -- no jq dependency needed)
- Poll `$JOBS_URL/{job_id}` every 5 seconds for up to 120 seconds
- Check for status "completed" OR status "failed" (either means pipeline ran)
- Print final job status
- Note: With USE_MOCK_DATA=true, all providers return mock data, so the pipeline should complete successfully

**Step 6: Verify Docker logs show pipeline stages**
- `docker compose logs web` -- check for "Pipeline execution started" or "pipeline"
- `docker compose logs celery-worker` -- check for "Task" (Celery task execution)
- Print summary of what was found in logs

**Final output:**
- Print "All validation checks passed" with service URLs
- Print "To stop services: docker compose down"
- Do NOT automatically stop services (user may want to inspect)

Make the script executable: `chmod +x scripts/validate-docker.sh`

IMPORTANT: Use `grep -o` and `cut` for JSON parsing, NOT jq (not guaranteed to be installed). Keep the script POSIX-compatible except for bash-specific features already in use.

IMPORTANT: The /generate endpoint is at root, NOT /api/generate. Routes are mounted without prefix.

IMPORTANT: The /generate endpoint accepts POST with no body required (PipelineTriggerRequest has all optional fields with defaults).
  </action>
  <verify>
Run `bash -n scripts/validate-docker.sh` to verify shell syntax. Run `chmod +x scripts/validate-docker.sh && ls -la scripts/validate-docker.sh` to confirm executable bit set.
  </verify>
  <done>scripts/validate-docker.sh exists, has no syntax errors, is executable, and contains all 6 validation steps.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Run validation and confirm Docker stack works</name>
  <files>scripts/validate-docker.sh</files>
  <action>
Run the validation script and have the user confirm the Docker Compose stack works end-to-end.

What was built: Complete Docker Compose stack with automated validation script. The stack includes PostgreSQL 16 with health check, Redis 7 with health check, FastAPI web service with auto-migration entrypoint and health check, and Celery worker with Redis broker. The validation script tests compose syntax, service health, API health endpoint, full pipeline execution, and Docker log output.

How to verify:
1. Make sure Docker Desktop is running
2. From project root, run: `./scripts/validate-docker.sh`
3. Watch the 6-step validation output
4. Expected result: All checks pass, health endpoint shows database=connected and redis=connected
5. After validation, optionally inspect:
   - `curl http://localhost:8000/health` (should return healthy)
   - `curl http://localhost:8000/jobs` (should show the pipeline job)
   - `docker compose logs web` (should show migration and startup logs)
   - `docker compose logs celery-worker` (should show task execution)
6. When done: `docker compose down` to stop services

Resume signal: Type "approved" if all validation checks pass, or describe any issues encountered.
  </action>
  <verify>User confirms the validation script ran successfully and all 6 checks passed.</verify>
  <done>User has approved the Docker Compose stack as working end-to-end with healthy services and successful pipeline execution.</done>
</task>

</tasks>

<verification>
1. `scripts/validate-docker.sh` exists and is executable
2. Script passes bash syntax check (`bash -n`)
3. Running the script completes all 6 steps without errors
4. Health endpoint returns status=healthy with database=connected and redis=connected
5. Pipeline trigger returns a job_id and job eventually reaches completed status
6. Docker logs show pipeline stage execution
</verification>

<success_criteria>
Validation script runs successfully end-to-end. User confirms Docker Compose stack starts all services, health checks pass, and full pipeline executes with mock data in Docker. INFRA-01 gap is closed.
</success_criteria>

<output>
After completion, create `.planning/phases/08-docker-compose-validation/08-02-SUMMARY.md`
</output>
