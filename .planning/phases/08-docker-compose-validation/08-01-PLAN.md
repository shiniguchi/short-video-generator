---
phase: 08-docker-compose-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dockerfile
  - docker-compose.yml
  - docker-entrypoint.sh
  - .env.example
autonomous: true

must_haves:
  truths:
    - "docker compose build completes without errors"
    - "docker compose up starts postgres, redis, web, and celery-worker containers"
    - "Alembic migrations run automatically on web container startup"
    - "Health endpoint returns healthy with database=connected and redis=connected"
    - "Celery worker connects to Redis broker and is ready to process tasks"
  artifacts:
    - path: "docker-entrypoint.sh"
      provides: "Migration runner + application starter"
      contains: "alembic upgrade head"
    - path: "Dockerfile"
      provides: "Container image with curl, alembic, and entrypoint"
      contains: "ENTRYPOINT"
    - path: "docker-compose.yml"
      provides: "Full stack orchestration with health checks"
      contains: "service_healthy"
    - path: ".env.example"
      provides: "Docker environment template with USE_MOCK_DATA"
      contains: "USE_MOCK_DATA"
  key_links:
    - from: "docker-compose.yml"
      to: "docker-entrypoint.sh"
      via: "entrypoint directive"
      pattern: "entrypoint.*docker-entrypoint"
    - from: "docker-entrypoint.sh"
      to: "alembic/env.py"
      via: "alembic upgrade head command"
      pattern: "alembic upgrade head"
    - from: "docker-compose.yml"
      to: ".env.example"
      via: "environment variable interpolation"
      pattern: "\\$\\{DATABASE_URL\\}"
---

<objective>
Make the Docker Compose stack bootable: fix Dockerfile to include alembic files and curl, create an entrypoint script that runs migrations before starting services, update docker-compose.yml with proper health checks and environment variables, and update .env.example with all required Docker env vars.

Purpose: The existing Dockerfile and docker-compose.yml were scaffolded in Phase 1 but never validated. The Dockerfile is missing alembic files (needed for migrations), curl (needed for health checks), and an entrypoint script. The compose file needs a web health check and USE_MOCK_DATA env var.

Output: A Docker Compose stack that builds and starts all 4 services with healthy status.
</objective>

<execution_context>
@/Users/naokitsk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naokitsk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-docker-compose-validation/08-RESEARCH.md
@Dockerfile
@docker-compose.yml
@.env.example
@alembic/env.py
@alembic.ini
@app/config.py
@app/database.py
@app/main.py
@app/worker.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create entrypoint script and update Dockerfile</name>
  <files>docker-entrypoint.sh, Dockerfile</files>
  <action>
1. Create `docker-entrypoint.sh` at project root:
   - Shebang: `#!/bin/bash` with `set -e`
   - Print "Running database migrations..." to stdout
   - Execute `alembic upgrade head` (idempotent -- safe on restarts)
   - Print "Migrations complete. Starting: $@"
   - Execute `exec "$@"` to hand off to the CMD

2. Update `Dockerfile` (currently uses python:3.11-slim):
   - Add `curl` to the apt-get install line (needed for web service health check)
   - After `COPY ./config /app/config`, add:
     - `COPY alembic.ini .`
     - `COPY ./alembic /app/alembic`
   - After `COPY ./app /app/app`, BEFORE the `RUN useradd` line, add:
     - `COPY docker-entrypoint.sh .`
     - `RUN chmod +x docker-entrypoint.sh`
   - After `USER appuser`, add: `ENTRYPOINT ["/app/docker-entrypoint.sh"]`
   - Keep `# Command specified in docker-compose.yml` as the last comment (no CMD)

   IMPORTANT: The Dockerfile uses python:3.11-slim (NOT 3.9). This is correct for Docker -- the Python 3.9 constraint only applies to the local dev venv. Keep python:3.11-slim.

   IMPORTANT: The COPY and chmod for docker-entrypoint.sh must happen BEFORE `USER appuser` since appuser does not have root permissions. But `chown -R appuser:appuser /app` already runs before USER switch, so the entrypoint will be owned by appuser.

   IMPORTANT: Alembic files must be copied BEFORE `RUN useradd` and `chown` so they get proper ownership.
  </action>
  <verify>
Run `docker compose build` and confirm it succeeds without errors. Check the image contains `/app/docker-entrypoint.sh`, `/app/alembic.ini`, and `/app/alembic/` by running:
`docker compose build && docker run --rm --entrypoint ls viralforge-web -la /app/docker-entrypoint.sh /app/alembic.ini /app/alembic/`
(Use the image name from docker compose build output)
  </verify>
  <done>Dockerfile builds successfully. Image contains entrypoint script, alembic.ini, alembic directory, and curl binary.</done>
</task>

<task type="auto">
  <name>Task 2: Update docker-compose.yml and .env.example</name>
  <files>docker-compose.yml, .env.example</files>
  <action>
1. Update `docker-compose.yml`:
   a. Add `start_period: 10s` to postgres healthcheck (gives PostgreSQL init time on first boot)
   b. Add `start_period: 5s` to redis healthcheck
   c. Add healthcheck to `web` service:
      ```yaml
      healthcheck:
        test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
        interval: 10s
        timeout: 5s
        retries: 5
        start_period: 30s
      ```
      The start_period of 30s accounts for: entrypoint migration time + uvicorn startup.
   d. Add `USE_MOCK_DATA=true` to both `web` and `celery-worker` environment lists. This is CRITICAL -- without it, the pipeline will try to call real external APIs (Claude, OpenAI, etc.) and fail.
   e. Add `ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY:-}` to both services environment (needed by config.py even in mock mode, to avoid validation errors -- empty string is fine)
   f. Add volumes mount for alembic directory to web service ONLY (for development, but entrypoint uses the COPY'd version):
      - Remove: No volume mount for alembic -- the image has the files baked in via COPY. Volume mounts for ./app already handle code hot-reload.
   g. Add `entrypoint: ["/app/docker-entrypoint.sh"]` to BOTH web and celery-worker services (worker also needs migrations to have run, and entrypoint is idempotent). Actually -- only add to web service. The worker should NOT run migrations (concurrent migration execution risk). Worker just needs to wait for web to be healthy. Add depends_on for celery-worker:
      ```yaml
      celery-worker:
        depends_on:
          postgres:
            condition: service_healthy
          redis:
            condition: service_healthy
          web:
            condition: service_healthy
      ```
      This ensures worker starts AFTER web has run migrations and is healthy.

   IMPORTANT: Do NOT add entrypoint to celery-worker. The worker's command `celery -A app.worker.celery_app worker --loglevel=info` should run directly. Only web needs the migration entrypoint.

   IMPORTANT: Routes are mounted at root (`app.include_router(routes.router)` with no prefix), so health check URL is `http://localhost:8000/health` (not `/api/health`).

2. Update `.env.example`:
   a. Add `USE_MOCK_DATA=true` after the API_SECRET_KEY line
   b. Add `ANTHROPIC_API_KEY=` (empty, for config validation)
   c. Add `OPENAI_API_KEY=` (empty, for config validation)

The .env file (local SQLite dev) should NOT be modified -- it already has USE_MOCK_DATA=true.
  </action>
  <verify>
Run `docker compose config --quiet` to validate the compose file syntax and variable interpolation. Then run `docker compose config` (without --quiet) and confirm:
- postgres healthcheck has start_period
- web has healthcheck with curl
- web and celery-worker both have USE_MOCK_DATA=true
- celery-worker depends_on includes web with service_healthy
  </verify>
  <done>docker-compose.yml passes validation. All 4 services have proper health checks. Worker depends on web being healthy (ensuring migrations ran). USE_MOCK_DATA=true set for both app services.</done>
</task>

</tasks>

<verification>
1. `docker compose config --quiet` passes (no syntax errors)
2. `docker compose build` succeeds
3. `docker compose up -d` starts all 4 services
4. `docker compose ps` shows postgres, redis as healthy within 30s
5. `docker compose ps` shows web as healthy within 60s (after migrations)
6. `docker compose ps` shows celery-worker as running (after web is healthy)
7. `curl http://localhost:8000/health` returns `{"status":"healthy","database":"connected","redis":"connected",...}`
</verification>

<success_criteria>
All 4 Docker Compose services (postgres, redis, web, celery-worker) start successfully with healthy status. Health endpoint confirms database and Redis connections work from within containers. Alembic migrations run automatically on first boot.
</success_criteria>

<output>
After completion, create `.planning/phases/08-docker-compose-validation/08-01-SUMMARY.md`
</output>
