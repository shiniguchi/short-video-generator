---
phase: 13-ugc-product-ad-pipeline
plan: 03
type: execute
wave: 2
depends_on: ["13-01", "13-02"]
files_modified:
  - app/tasks.py
  - app/api/routes.py
  - app/services/ugc_pipeline/__init__.py
autonomous: true

must_haves:
  truths:
    - "API endpoint POST /api/ugc-ad-generate accepts product images (multipart) + metadata (Form fields) and returns job_id + task_id"
    - "generate_ugc_ad_task orchestrates full pipeline: analyze product -> hero image -> script -> A-Roll -> B-Roll -> composite"
    - "Pipeline runs end-to-end with mock providers (no API keys) producing a final video file"
    - "Job status is trackable via existing GET /api/jobs/{job_id} endpoint"
    - "Pipeline has 30-minute task timeout for long-running asset generation"
  artifacts:
    - path: "app/tasks.py"
      provides: "generate_ugc_ad_task Celery task"
      contains: "def generate_ugc_ad_task"
    - path: "app/api/routes.py"
      provides: "POST /api/ugc-ad-generate endpoint"
      contains: "ugc-ad-generate"
    - path: "app/services/ugc_pipeline/__init__.py"
      provides: "Updated exports including asset_generator and ugc_compositor"
      contains: "compose_ugc_ad"
  key_links:
    - from: "app/api/routes.py"
      to: "app/tasks.py"
      via: "generate_ugc_ad_task.delay()"
      pattern: "generate_ugc_ad_task\\.delay"
    - from: "app/tasks.py"
      to: "app/services/ugc_pipeline"
      via: "imports analyze_product, generate_ugc_script, asset_generator, ugc_compositor"
      pattern: "from app.services.ugc_pipeline"
    - from: "app/api/routes.py"
      to: "app/models.py"
      via: "Creates Job record for tracking"
      pattern: "Job\\("
---

<objective>
Wire up the UGC pipeline with a Celery orchestrator task and FastAPI endpoint for end-to-end product ad generation.

Purpose: Connects all the service modules (product_analyzer, script_engine, asset_generator, ugc_compositor) into a single orchestrated pipeline triggered by an API endpoint. Creates the Job record for status tracking via existing /api/jobs infrastructure.

Output: A working POST /api/ugc-ad-generate endpoint that accepts product images + metadata, queues the full pipeline, and returns a poll URL for status tracking. Pipeline produces a final 9:16 MP4 video in output/review/.
</objective>

<execution_context>
@/Users/naokitsk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naokitsk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-ugc-product-ad-pipeline/13-RESEARCH.md
@.planning/phases/13-ugc-product-ad-pipeline/13-01-SUMMARY.md
@.planning/phases/13-ugc-product-ad-pipeline/13-02-SUMMARY.md
@app/tasks.py
@app/api/routes.py
@app/pipeline.py
@app/models.py
@app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create generate_ugc_ad_task in app/tasks.py</name>
  <files>app/tasks.py, app/services/ugc_pipeline/__init__.py</files>
  <action>
**Update app/services/ugc_pipeline/__init__.py** to export all functions:
```python
"""UGC Product Ad Pipeline services."""
from app.services.ugc_pipeline.product_analyzer import analyze_product
from app.services.ugc_pipeline.script_engine import generate_ugc_script
from app.services.ugc_pipeline.asset_generator import generate_hero_image, generate_aroll_assets, generate_broll_assets
from app.services.ugc_pipeline.ugc_compositor import compose_ugc_ad

__all__ = [
    "analyze_product", "generate_ugc_script",
    "generate_hero_image", "generate_aroll_assets", "generate_broll_assets",
    "compose_ugc_ad"
]
```

**Add generate_ugc_ad_task to app/tasks.py** (append after compose_video_task):

```python
@celery_app.task(
    bind=True,
    name='app.tasks.generate_ugc_ad_task',
    max_retries=1,
    time_limit=1800,  # 30 minutes for full pipeline
)
def generate_ugc_ad_task(self, job_id, product_name, description, product_images, product_url=None, target_duration=30, style_preference=None):
```

**Implementation steps inside the task (all lazy-imported to avoid circular imports):**

1. **Update Job status** to running:
   ```python
   from app.pipeline import _update_job_status, _mark_job_failed, _mark_job_complete
   asyncio.run(_update_job_status(job_id, "ugc_product_analysis", "running"))
   ```

2. **Step 1 — Product Analysis:**
   ```python
   from app.services.ugc_pipeline.product_analyzer import analyze_product
   analysis = analyze_product(
       product_name=product_name,
       description=description,
       image_count=len(product_images),
       style_preference=style_preference
   )
   logger.info(f"Product analysis: category={analysis.category}, style={analysis.ugc_style}")
   ```

3. **Step 2 — Hero Image Generation:**
   ```python
   from app.services.ugc_pipeline.asset_generator import generate_hero_image
   hero_image_path = generate_hero_image(
       product_image_path=product_images[0],  # Use first uploaded image
       ugc_style=analysis.ugc_style,
       emotional_tone=analysis.emotional_tone,
       visual_keywords=analysis.visual_keywords
   )
   logger.info(f"Hero image: {hero_image_path}")
   ```

4. **Step 3 — Script Generation:**
   ```python
   from app.services.ugc_pipeline.script_engine import generate_ugc_script
   breakdown = generate_ugc_script(
       product_name=product_name,
       description=description,
       analysis=analysis,
       target_duration=target_duration
   )
   logger.info(f"Script: {len(breakdown.aroll_scenes)} A-Roll scenes, {len(breakdown.broll_shots)} B-Roll shots")
   ```

5. **Step 4 — A-Roll Asset Generation:**
   ```python
   from app.services.ugc_pipeline.asset_generator import generate_aroll_assets
   aroll_scenes_dicts = [s.model_dump() if hasattr(s, 'model_dump') else s for s in breakdown.aroll_scenes]
   aroll_paths = generate_aroll_assets(
       aroll_scenes=aroll_scenes_dicts,
       hero_image_path=hero_image_path
   )
   logger.info(f"A-Roll clips: {len(aroll_paths)}")
   ```

6. **Step 5 — B-Roll Asset Generation:**
   ```python
   from app.services.ugc_pipeline.asset_generator import generate_broll_assets
   broll_shots_dicts = [s.model_dump() if hasattr(s, 'model_dump') else s for s in breakdown.broll_shots]
   broll_paths = generate_broll_assets(
       broll_shots=broll_shots_dicts,
       product_image_path=product_images[0]
   )
   logger.info(f"B-Roll clips: {len(broll_paths)}")
   ```

7. **Step 6 — Final Composition:**
   ```python
   from app.services.ugc_pipeline.ugc_compositor import compose_ugc_ad
   from app.config import get_settings
   from uuid import uuid4
   import os

   settings = get_settings()
   output_path = os.path.join(settings.composition_output_dir, f"ugc_ad_{uuid4().hex[:8]}.mp4")
   os.makedirs(settings.composition_output_dir, exist_ok=True)

   # Build broll_metadata with paths and overlay_start from breakdown
   broll_metadata = []
   for i, shot_dict in enumerate(broll_shots_dicts):
       broll_metadata.append({
           "path": broll_paths[i],
           "overlay_start": shot_dict.get("overlay_start", 0.0)
       })

   final_path = compose_ugc_ad(
       aroll_paths=aroll_paths,
       broll_metadata=broll_metadata,
       output_path=output_path
   )
   logger.info(f"Final video: {final_path}")
   ```

8. **Step 7 — Save Video Record to DB:**
   ```python
   # Save Video record (same async pattern as compose_video_task)
   async def _save_ugc_video(job_id, file_path, product_name, analysis_category):
       from app.database import get_task_session_factory
       from app.models import Video
       from datetime import datetime, timezone

       async with get_task_session_factory()() as session:
           video = Video(
               job_id=job_id,
               file_path=file_path,
               status="generated",
               cost_usd=0.0,  # Mock providers have zero cost
               extra_data={
                   "gen_id": uuid4().hex,
                   "timestamp": datetime.now(timezone.utc).isoformat(),
                   "pipeline": "ugc_product_ad",
                   "product_name": product_name,
                   "category": analysis_category,
                   "status": "generated"
               }
           )
           session.add(video)
           await session.commit()
           await session.refresh(video)
           return video.id

   video_id = asyncio.run(_save_ugc_video(job_id, final_path, product_name, analysis.category))
   ```

9. **Step 8 — Mark Job Complete:**
   ```python
   asyncio.run(_mark_job_complete(job_id))
   ```

10. **Return result:**
    ```python
    return {
        "status": "completed",
        "job_id": job_id,
        "video_id": video_id,
        "video_path": final_path,
        "product_name": product_name,
        "category": analysis.category,
        "aroll_scenes": len(breakdown.aroll_scenes),
        "broll_shots": len(breakdown.broll_shots)
    }
    ```

11. **Wrap entire body in try/except** — on exception, call `asyncio.run(_mark_job_failed(job_id, "ugc_pipeline", str(exc)))` and re-raise.

IMPORTANT: Use `from typing import Optional, List` not `list[str]` (Python 3.9).
  </action>
  <verify>Run `python -c "from app.tasks import generate_ugc_ad_task; print(f'Task name: {generate_ugc_ad_task.name}')"` — should print "app.tasks.generate_ugc_ad_task".</verify>
  <done>generate_ugc_ad_task is registered as a Celery task with 30-min time_limit. It orchestrates all 7 pipeline steps: product analysis -> hero image -> script -> A-Roll -> B-Roll -> composition -> DB save. Uses existing Job status tracking and marks job complete/failed. Works with mock providers.</done>
</task>

<task type="auto">
  <name>Task 2: Add POST /api/ugc-ad-generate endpoint to routes.py</name>
  <files>app/api/routes.py</files>
  <action>
Append a new section to app/api/routes.py after the Pipeline Integration section (after the retry_job endpoint). Add a section comment: `# --- Phase 13: UGC Product Ad Pipeline ---`

**Add endpoint:**
```python
@router.post("/ugc-ad-generate")
async def generate_ugc_ad(
    product_name: str = Form(...),
    description: str = Form(...),
    product_url: Optional[str] = Form(None),
    target_duration: int = Form(30),
    style_preference: Optional[str] = Form(None),
    images: List[UploadFile] = File(..., description="Product photos (1-5 images)"),
    session: AsyncSession = Depends(get_session)
):
```

**Required imports at top of file** (add to existing imports):
- Add `from fastapi import ... Form, File, UploadFile` to the existing fastapi import line
- Add `from typing import List` if not already imported (it should be — Optional is already imported)

**Implementation:**
1. Validate image count: `if len(images) > 5: raise HTTPException(400, "Maximum 5 product images allowed")`
2. Validate each image is actually an image: `if not image.content_type or not image.content_type.startswith("image/"): raise HTTPException(400, f"File {image.filename} is not an image")`
3. Save uploaded images to `output/uploads/` directory:
   ```python
   import os
   from uuid import uuid4

   upload_dir = "output/uploads"
   os.makedirs(upload_dir, exist_ok=True)

   product_image_paths = []
   for image in images:
       filename = f"{uuid4().hex[:8]}_{image.filename}"
       image_path = os.path.join(upload_dir, filename)
       content = await image.read()
       with open(image_path, "wb") as f:
           f.write(content)
       product_image_paths.append(image_path)
   ```
4. Create Job record (same pattern as trigger_pipeline):
   ```python
   from app.models import Job

   job = Job(
       status="pending",
       stage="ugc_product_analysis",
       theme=f"ugc:{product_name}",
       extra_data={
           "completed_stages": [],
           "pipeline": "ugc_product_ad",
           "product_name": product_name
       }
   )
   session.add(job)
   await session.commit()
   await session.refresh(job)
   ```
5. Queue Celery task (lazy import to avoid circular deps):
   ```python
   from app.tasks import generate_ugc_ad_task
   task = generate_ugc_ad_task.delay(
       job_id=job.id,
       product_name=product_name,
       description=description,
       product_images=product_image_paths,
       product_url=product_url,
       target_duration=target_duration,
       style_preference=style_preference
   )
   ```
6. Return UGCAdResponse:
   ```python
   from app.schemas import UGCAdResponse
   return UGCAdResponse(
       job_id=job.id,
       task_id=str(task.id),
       status="queued",
       poll_url=f"/api/jobs/{job.id}",
       message=f"UGC ad generation started for '{product_name}'"
   )
   ```

IMPORTANT: Use `from typing import List, Optional` at top level (Python 3.9 compat). Do NOT use `list[UploadFile]`.
  </action>
  <verify>Run `python -c "from app.api.routes import router; routes = [r.path for r in router.routes]; print('/ugc-ad-generate' in routes)"` — should print True. Also verify FastAPI starts: `timeout 5 python -c \"from app.main import app; print('App created with', len(app.routes), 'routes')\"` (should succeed without import errors).</verify>
  <done>POST /api/ugc-ad-generate endpoint accepts multipart product_name, description, product_url, target_duration, style_preference (Form fields) and images (File uploads). Creates Job record, saves uploaded images, queues generate_ugc_ad_task, returns UGCAdResponse with poll_url. Validates image count (max 5) and content type. Job status trackable via existing GET /api/jobs/{job_id}.</done>
</task>

</tasks>

<verification>
1. generate_ugc_ad_task is a registered Celery task with 30-min time_limit
2. POST /api/ugc-ad-generate endpoint exists and accepts multipart form data
3. Endpoint creates Job record with pipeline="ugc_product_ad" in extra_data
4. Task orchestrates all steps: analyze -> hero image -> script -> A-Roll -> B-Roll -> compose -> DB save
5. Job status updates through pipeline stages
6. FastAPI app starts without import errors
7. No Python 3.9 incompatible syntax
</verification>

<success_criteria>
- POST /api/ugc-ad-generate accepts product images + metadata and returns {job_id, task_id, status, poll_url}
- generate_ugc_ad_task runs full pipeline end-to-end with mock providers
- Final video saved to output/review/ directory
- Video record saved to DB with UGC-specific metadata
- Job status trackable via GET /api/jobs/{job_id}
- Pipeline works without API keys (USE_MOCK_DATA=true)
</success_criteria>

<output>
After completion, create `.planning/phases/13-ugc-product-ad-pipeline/13-03-SUMMARY.md`
</output>
