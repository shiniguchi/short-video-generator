---
phase: 04-video-composition
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - app/tasks.py
  - app/api/routes.py
  - app/config.py

autonomous: true

must_haves:
  truths:
    - "compose_video_task Celery task accepts script_id, video_path, audio_path and produces final composed video"
    - "POST /compose-video API endpoint triggers composition task and returns task_id"
    - "GET /videos endpoint lists composed videos with file_path, thumbnail_path, duration, status"
    - "Composition task saves Video record to database with file_path, thumbnail_path, and duration_seconds"
    - "generate_content_task can optionally chain into compose_video_task for end-to-end pipeline"
  artifacts:
    - path: "app/tasks.py"
      provides: "compose_video_task Celery task"
      contains: "def compose_video_task"
    - path: "app/api/routes.py"
      provides: "Composition and video listing endpoints"
      contains: "compose-video"
    - path: "app/config.py"
      provides: "Composition settings (music_volume, thumbnail_timestamp)"
      contains: "music_volume"
  key_links:
    - from: "app/tasks.py"
      to: "app/services/video_compositor/compositor.py"
      via: "import VideoCompositor"
      pattern: "from app.services.video_compositor import VideoCompositor"
    - from: "app/tasks.py"
      to: "app/models.py"
      via: "save Video record to database"
      pattern: "Video\\("
    - from: "app/api/routes.py"
      to: "app/tasks.py"
      via: "trigger compose_video_task"
      pattern: "compose_video_task.delay"
---

<objective>
Integrate VideoCompositor into the Celery task pipeline and expose API endpoints for triggering composition and listing composed videos.

Purpose: Connects the VideoCompositor service (Plan 01) to the application's task queue and REST API, enabling end-to-end video generation from content to composed output. Completes the Phase 4 pipeline integration.

Output: compose_video_task in tasks.py, composition API endpoints in routes.py, composition config settings.
</objective>

<execution_context>
@/Users/naokitsk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naokitsk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-video-composition/04-RESEARCH.md
@.planning/phases/04-video-composition/04-01-SUMMARY.md

@app/tasks.py — existing generate_content_task returns {script_id, video_path, audio_path}
@app/api/routes.py — existing endpoints pattern
@app/config.py — Settings class
@app/models.py — Video model (id, script_id, file_path, thumbnail_path, duration_seconds, status, cost_usd)
@app/schemas.py — TextOverlaySchema
@app/database.py — get_session, async_session_factory
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add compose_video_task to Celery tasks and composition config</name>
  <files>
    app/tasks.py
    app/config.py
  </files>
  <action>
**app/config.py — Add composition settings to Settings class:**
- `background_music_path: str = ""` — path to background music file (empty = no music)
- `music_volume: float = 0.3` — background music volume (0.0-1.0), default 30%
- `thumbnail_timestamp: float = 2.0` — seconds into video to extract thumbnail frame
- `composition_output_dir: str = "output/final"` — directory for composed videos

**app/tasks.py — Add compose_video_task:**
```
@celery_app.task(
    bind=True,
    name='app.tasks.compose_video_task',
    max_retries=2,
    autoretry_for=(Exception,),
    retry_backoff=True,
    retry_backoff_max=600,
    retry_jitter=True,
)
def compose_video_task(self, script_id: int, video_path: str, audio_path: str):
```

Task flow:
1. Load Script from database by script_id (use asyncio.run with async session)
2. Extract text_overlays from Script.text_overlays JSON field
3. Convert text_overlays dicts to TextOverlaySchema objects: `[TextOverlaySchema(**t) for t in text_overlays_raw]`
4. Get settings for music_volume, background_music_path, thumbnail_timestamp, composition_output_dir
5. Create VideoCompositor(output_dir=settings.composition_output_dir)
6. Call compositor.compose(video_path, audio_path, text_overlays, background_music_path=settings.background_music_path or None, music_volume=settings.music_volume, thumbnail_timestamp=settings.thumbnail_timestamp)
7. Save Video record to database: `Video(script_id=script_id, file_path=result["video_path"], thumbnail_path=result["thumbnail_path"], duration_seconds=result["duration"], status="generated")`
8. Return `{"status": "success", "video_id": video_id, "video_path": result["video_path"], "thumbnail_path": result["thumbnail_path"], "duration": result["duration"]}`

For DB access in Celery task, follow existing pattern from generate_content_task: use `asyncio.run()` with async helper functions. Create helper `_save_video_record(script_id, file_path, thumbnail_path, duration)` that creates async session and inserts Video row.

Also update generate_content_task to optionally chain into compose_video_task:
- After existing step 6 (voiceover generation), add step 7:
- `compose_result = compose_video_task.delay(script_id, video_path, audio_path)` (non-blocking, separate task)
- Add `compose_task_id` to result dict
- Log the chaining: `logger.info(f"Composition task queued: {compose_result.id}")`

Import pattern (inside task function to avoid circular imports):
- `from app.services.video_compositor import VideoCompositor`
- `from app.schemas import TextOverlaySchema`
- `from app.config import get_settings`
  </action>
  <verify>
Run: `python -c "from app.tasks import compose_video_task; print(f'Task registered: {compose_video_task.name}')"` — should print task name.
Run: `python -c "from app.config import get_settings; s = get_settings(); print(f'music_volume={s.music_volume}, thumbnail_ts={s.thumbnail_timestamp}')"` — should show default values.
  </verify>
  <done>compose_video_task exists as registered Celery task, accepts (script_id, video_path, audio_path), uses VideoCompositor, saves Video record to DB. generate_content_task chains into compose_video_task. Config has composition settings.</done>
</task>

<task type="auto">
  <name>Task 2: Add composition and video listing API endpoints</name>
  <files>
    app/api/routes.py
  </files>
  <action>
Add three new endpoints to app/api/routes.py following existing endpoint patterns:

**POST /compose-video:**
- Accept JSON body: `{"script_id": int, "video_path": str, "audio_path": str}`
- Trigger `compose_video_task.delay(script_id, video_path, audio_path)`
- Return `{"task_id": str(task.id), "status": "queued", "description": "Composing final video..."}`
- Use same pattern as `/generate-content` endpoint

**GET /videos:**
- List composed videos from Video table
- Accept optional query params: `limit: int = 10`, `status: Optional[str] = None`
- Query Video table ordered by created_at desc
- Filter by status if provided (generated, approved, rejected)
- Return `{"count": N, "videos": [{id, script_id, file_path, thumbnail_path, duration_seconds, status, cost_usd, created_at}]}`
- Follow same pattern as `/scripts` endpoint

**GET /videos/{video_id}:**
- Get single video record by ID
- Return all Video fields including extra_data
- Raise 404 if not found
- Follow same pattern as `/scripts/{script_id}` endpoint

Add section comment `# --- Phase 4: Video Composition ---` before new endpoints for consistency with existing code organization.
  </action>
  <verify>
Run: `python -c "from app.api.routes import router; routes = [r.path for r in router.routes]; print([r for r in routes if 'video' in r or 'compose' in r])"` — should show compose-video and videos routes.
  </verify>
  <done>Three new endpoints exist: POST /compose-video triggers composition task, GET /videos lists composed videos, GET /videos/{id} shows video details. All follow existing code patterns.</done>
</task>

</tasks>

<verification>
1. `python -c "from app.tasks import compose_video_task; print(compose_video_task.name)"` — prints 'app.tasks.compose_video_task'
2. `python -c "from app.config import get_settings; s = get_settings(); print(s.music_volume, s.thumbnail_timestamp, s.composition_output_dir)"` — prints defaults
3. `python -c "from app.api.routes import router; routes = [r.path for r in router.routes]; assert '/compose-video' in routes; assert '/videos' in routes; assert '/videos/{video_id}' in routes; print('All endpoints registered')"` — confirms endpoints
4. Verify generate_content_task chains into compose_video_task by checking for compose_video_task reference in tasks.py
</verification>

<success_criteria>
- compose_video_task registered as Celery task with retry config
- Task loads Script from DB, extracts text_overlays, calls VideoCompositor.compose()
- Task saves Video record (file_path, thumbnail_path, duration_seconds) to database
- generate_content_task chains into compose_video_task after video/voiceover generation
- POST /compose-video triggers composition task
- GET /videos lists composed videos with filtering by status
- GET /videos/{id} returns full video details
- Config has music_volume (0.3), thumbnail_timestamp (2.0), composition_output_dir, background_music_path settings
</success_criteria>

<output>
After completion, create `.planning/phases/04-video-composition/04-02-SUMMARY.md`
</output>
